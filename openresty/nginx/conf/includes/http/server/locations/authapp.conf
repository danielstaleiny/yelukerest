

location /auth/ {
    # MIME type determined by default_type:
    default_type 'text/html';

      location /auth/redis {
            content_by_lua_block {
                local redis = require "resty.redis"
                local red = redis:new()

                red:set_timeouts(1000, 1000, 1000) -- 1 sec

                -- or connect to a unix domain socket file listened
                -- by a redis server:
                --     local ok, err = red:connect("unix:/path/to/redis.sock")

                local ok, err = red:connect("redis", 6379)
                if not ok then
                    ngx.say("failed to connect: ", err)
                    return
                end

                ok, err = red:set("dog", "an animal")
                if not ok then
                    ngx.say("failed to set dog: ", err)
                    return
                end

                ngx.say("set result: ", ok)

                local res, err = red:get("dog")
                if not res then
                    ngx.say("failed to get dog: ", err)
                    return
                end

                if res == ngx.null then
                    ngx.say("dog not found.")
                    return
                end

                ngx.say("dog: ", res)

                red:init_pipeline()
                red:set("cat", "Marry")
                red:set("horse", "Bob")
                red:get("cat")
                red:get("horse")
                local results, err = red:commit_pipeline()
                if not results then
                    ngx.say("failed to commit the pipelined requests: ", err)
                    return
                end

                for i, res in ipairs(results) do
                    if type(res) == "table" then
                        if res[1] == false then
                            ngx.say("failed to run command ", i, ": ", res[2])
                        else
                            -- process the table value
                        end
                    else
                        -- process the scalar value
                    end
                end

                -- put it into the connection pool of size 100,
                -- with 10 seconds max idle time
                local ok, err = red:set_keepalive(10000, 100)
                if not ok then
                    ngx.say("failed to set keepalive: ", err)
                    return
                end

                -- or just close the connection right away:
                -- local ok, err = red:close()
                -- if not ok then
                --     ngx.say("failed to close: ", err)
                --     return
                -- end
            }
        }

    location /auth/ {
        content_by_lua '
            ngx.say("<html><body><a href=/auth/start>Start the test</a>!</body></html>")
        ';
    }
    location /auth/start {
        content_by_lua '
            local session = require "resty.session".start()
            session.data.name = "OpenResty Fan"
            session:save()
            ngx.say("<html><body>Session started. ",
                    "<a href=/auth/test>Check if it is working</a>!</body></html>")
        ';
    }
    location /auth/test {
        content_by_lua '
            local session = require "resty.session".open()
            ngx.say("<html><body>Session was started by <strong>",
                    session.data.name or "Anonymous",
                    "</strong>! <a href=/auth/modify>Modify the session</a>.</body></html>")
        ';
    }
    location /auth/modify {
        content_by_lua '
            local session = require "resty.session".start()
            session.data.name = "Lua Fan"
            session:save()
            ngx.say("<html><body>Session modified. ",
                    "<a href=/auth/modified>Check if it is modified</a>!</body></html>")
        ';
    }
    location /auth/modified {
        content_by_lua '
            local session = require "resty.session".open()
            ngx.say("<html><body>Session was modified by <strong>",
                    session.data.name or "Anonymous",
                    "</strong>! <a href=/auth/destroy>Destroy the session</a>.</body></html>")
        ';
    }
    location /auth/destroy {
        content_by_lua '
            require "resty.session".destroy()
            ngx.say("<html><body>Session was destroyed. ",
                    "<a href=/auth/check>Is it really so</a>?</body></html>")
        ';
    }
    location /auth/check {
        content_by_lua '
            local session = require "resty.session".open()
            ngx.say("<html><body>Session was really destroyed, you are known as ",
                    "<strong>",
                    session.data.name or "Anonymous",
                    "</strong>! <a href=/auth/>Start again</a>.</body></html>")
        ';
}
}