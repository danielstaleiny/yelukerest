version: '3.2'
services:

  # This is the database to which the all the other components in the stack will connect and interact with
  # (but mostly it's PostgREST that is going to be responsible for the bulk of the db traffic)
  # Having the database in a container is very convinient in development but in production you will
  # use a separate database instance, like Amazon RDS, i.e. in production this section will be
  # commented and in the .env file you will specify the ip of your separate database instance
  db:
    image: ${PG_DOCKER_IMAGE}
    ports:
      - "127.0.0.1:5432:${DB_PORT}"
    environment:
      # env vars specific to postgres image used on first boot
      - POSTGRES_USER=${SUPER_USER}
      - POSTGRES_PASSWORD=${SUPER_USER_PASSWORD}
      - POSTGRES_DB=${DB_NAME}
      # env vars useful for our sql scripts
      - SUPER_USER=${SUPER_USER}
      - SUPER_USER_PASSWORD=${SUPER_USER_PASSWORD}
      - DB_NAME=${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_PASS=${DB_PASS}
      - DB_ANON_ROLE=${DB_ANON_ROLE}
      - DEVELOPMENT=${DEVELOPMENT}
      - JWT_SECRET=${JWT_SECRET}
      - AUTHAPP_DB_PASS=${AUTHAPP_DB_PASS}
      - AUTHAPP_DB_USER=${AUTHAPP_DB_USER}

    volumes:
      - "./db/src:/docker-entrypoint-initdb.d"


  mockcas:
    build: mockcas
    # Set the location where docker will put our files
    working_dir: /opt/app
    # Map port 8081 on our host to port 4000 inside the container.
    # Our node app should then run on port 4000 inside the container.
    ports:
      - "127.0.0.1:${MOCKCAS_HOST_PORT}:${MOCKCAS_PORT}"
    environment:
      - DEVELOPMENT=${DEVELOPMENT}
      - PORT=${MOCKCAS_PORT}
    volumes:
      # Note that the package.json-like files were moved into the
      # container as specified by the elmclient/Dockerfile.
      - "./mockcas/src:/opt/app/src"
      - "./mockcas/run.sh:/opt/app/run.sh"
    entrypoint: "/opt/app/run.sh"


  authapp:
    build: authapp
    # Set the location where docker will put our files
    working_dir: /app
    # Map port 8081 on our host to port 4000 inside the container.
    # Our node app should then run on port 4000 inside the container.
    ports:
      - "127.0.0.1:8081:${AUTHAPP_PORT}"
    # Link this app to the `db` app so that we can talk to postgres
    # when we need to do so. We might also want to talk to the rest
    # API directly, and we'll need to add that if so.
    links:
      - redis:redis
      - mockcas:mockcas
    environment:
      # Pass in connection information for the database.
      - DB_URI=postgres://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}
      # The express app will likely manage some of our JWT signing
      # because we want to use Yale CAS auth infront of our app so
      # that we can avoid storing passwords.
      # - JWT_SECRET=${JWT_SECRET}  
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
      - SESSION_SECRET=${AUTHAPP_SESSION_SECRET}
      - DEVELOPMENT=${DEVELOPMENT}
      - CAS_HOST=${AUTHAPP_CAS_HOST}
      - CAS_SERVICE_VALIDATE_HOST=${AUTHAPP_CAS_SERVICE_VALIDATE_HOST}
      - CAS_PROTOCOL=${AUTHAPP_CAS_PROTOCOL}
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT}
      - DB_SCHEMA=${DB_SCHEMA}
      - DB_NAME=${DB_NAME}
      - DB_USER=${AUTHAPP_DB_USER}
      - DB_PASS=${AUTHAPP_DB_PASS}
      - JWT_SECRET=${JWT_SECRET}

    volumes:
      # These are the files we wish to "move" into the docker container.
      # Note that, they are not moved, just mounted---when they are
      # edited on the host they will be changed in the container.
      # - "./authapp/package.json:/app/package.json"
      # - "./authapp/package-lock.json:/app/package-lock.json"
      - "./authapp/src:/app/src"
      - "./authapp/run.sh:/app/run.sh"
    # The script that is run to start our process.
    entrypoint: "/app/run.sh"

  #sharedterminal:
  #  build: sharedterminal
  #  environment:
  #    - SHAREDTERMINAL_PORT=${SHAREDTERMINAL_PORT}
