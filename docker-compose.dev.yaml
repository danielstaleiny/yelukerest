version: '3.2'
services:

  # This is the database to which the all the other components in the stack will connect and interact with
  # (but mostly it's PostgREST that is going to be responsible for the bulk of the db traffic)
  # Having the database in a container is very convinient in development but in production you will
  # use a separate database instance, like Amazon RDS, i.e. in production this section will be
  # commented and in the .env file you will specify the ip of your separate database instance
  db:
    image: postgres:9.6
    ports:
      - "5432:${DB_PORT}"
    environment:
      # env vars specific to postgres image used on first boot
      - POSTGRES_USER=${SUPER_USER}
      - POSTGRES_PASSWORD=${SUPER_USER_PASSWORD}
      - POSTGRES_DB=${DB_NAME}
      # env vars useful for our sql scripts
      - SUPER_USER=${SUPER_USER}
      - SUPER_USER_PASSWORD=${SUPER_USER_PASSWORD}
      - DB_NAME=${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_PASS=${DB_PASS}
      - DB_ANON_ROLE=${DB_ANON_ROLE}
      - DEVELOPMENT=${DEVELOPMENT}
      - JWT_SECRET=${JWT_SECRET}
      - AUTHAPP_DB_PASS=${AUTHAPP_DB_PASS}
      - AUTHAPP_DB_USER=${AUTHAPP_DB_USER}

    volumes:
      - "./db/src:/docker-entrypoint-initdb.d"


  mockcas:
    build: mockcas
    # Set the location where docker will put our files
    working_dir: /opt/app
    # Map port 8081 on our host to port 4000 inside the container.
    # Our node app should then run on port 4000 inside the container.
    ports:
      - "${MOCKCAS_HOST_PORT}:${MOCKCAS_PORT}"
    environment:
      - DEVELOPMENT=${DEVELOPMENT}
      - PORT=${MOCKCAS_PORT}
    volumes:
      # Note that the package.json-like files were moved into the
      # container as specified by the elmclient/Dockerfile.
      - "./mockcas/src:/opt/app/src"
      - "./mockcas/run.sh:/opt/app/run.sh"
    entrypoint: "/opt/app/run.sh"