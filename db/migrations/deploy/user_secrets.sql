-- Deploy yelukerest:user_secrets to pg
-- requires: init

BEGIN;


CREATE TABLE IF NOT EXISTS user_secret (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    slug TEXT NOT NULL
        CHECK (slug ~ '^[a-z0-9][a-z0-9_-]+[a-z0-9]$' AND char_length(slug) < 100),
    body TEXT NOT NULL,
    user_id INT REFERENCES "user"(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE,
    team_nickname TEXT REFERENCES team(nickname)
        ON DELETE CASCADE
        ON UPDATE CASCADE
        CHECK (char_length(team_nickname) < 50),
    created_at TIMESTAMP WITH TIME ZONE
        NOT NULL
        DEFAULT current_timestamp,
    updated_at  TIMESTAMP WITH TIME ZONE
        NOT NULL
        DEFAULT current_timestamp,
    CONSTRAINT updated_after_created CHECK (updated_at >= created_at),
    CONSTRAINT user_or_team CHECK (
        ((team_nickname IS NOT NULL) AND (user_id IS NULL))
        OR
        ((team_nickname IS NULL) AND (user_id IS NOT NULL))
    )
);

-- Slug is unique per team and user
DROP INDEX IF EXISTS secret_unique_slug_user;
CREATE UNIQUE INDEX secret_unique_slug_user
    ON user_secret (user_id, slug)
    WHERE team_nickname IS NULL;
DROP INDEX IF EXISTS secret_unique_slug_team;
CREATE UNIQUE INDEX secret_unique_slug_team
    ON user_secret (team_nickname, slug)
    WHERE user_id IS NULL;

CREATE OR REPLACE FUNCTION fill_user_secret_defaults()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = current_timestamp;
    RETURN NEW;
END;
$$ language 'plpgsql';


DROP TRIGGER IF EXISTS tg_user_secret_default ON user_secret;
CREATE TRIGGER tg_user_secret_default
    BEFORE INSERT OR UPDATE
    ON user_secret
    FOR EACH ROW
EXECUTE PROCEDURE fill_user_secret_defaults();


create or replace view user_secrets as
    select * from data.user_secret;

-- It is important to set the correct owner so the RLS policy kicks in.
alter view user_secrets owner to api;

-- Let the `api` role---the view owner---query the data.
grant select, insert, update, delete on data.user_secret to api;

-- Define the who can access user_secret data.
-- Enable RLS on the table holding the data.
alter table data.user_secret enable row level security;

-- Define the RLS policy controlling what rows are visible to a
-- particular user.
create policy user_secret_access_policy on data.user_secret to api 
using (
	( 
        -- If the role is student
        request.user_role() = ANY('{student,ta}'::text[])
        -- They can see rows in the user_secrets table if
        and (
            -- The secret belongs to them
            (request.user_id() = user_id)
            or
            -- The secret belongs to their team
            EXISTS(
                SELECT u.id FROM api.users as u
                WHERE
                    u.id = request.user_id()
                    AND
                    u.team_nickname = user_secret.team_nickname
            )
        )
    )
	OR
	-- faculty can see user_secret by all users
	(request.user_role() = 'faculty')
) WITH CHECK (
    -- Only faculty can write secrets
    request.user_role() = 'faculty'
);

-- Students can read and faculty can read-write
grant select on api.user_secrets to student, ta;
grant select, insert, update, delete on api.user_secrets to faculty;



COMMIT;
