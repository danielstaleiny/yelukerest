version: '3.2'
volumes:
  # A named volume to share data between containers
  elmclient-build:
    external: false
services:

  # This is the database to which the all the other components in the stack will connect and interact with
  # (but mostly it's PostgREST that is going to be responsible for the bulk of the db traffic)
  # Having the database in a container is very convinient in development but in production you will
  # use a separate database instance, like Amazon RDS, i.e. in production this section will be
  # commented and in the .env file you will specify the ip of your separate database instance
  db:
    image: postgres:9.6
    ports:
      - "5432:${DB_PORT}"
    environment:
      # env vars specific to postgres image used on first boot
      - POSTGRES_USER=${SUPER_USER}
      - POSTGRES_PASSWORD=${SUPER_USER_PASSWORD}
      - POSTGRES_DB=${DB_NAME}
      # env vars useful for our sql scripts
      - SUPER_USER=${SUPER_USER}
      - SUPER_USER_PASSWORD=${SUPER_USER_PASSWORD}
      - DB_NAME=${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_PASS=${DB_PASS}
      - DB_ANON_ROLE=${DB_ANON_ROLE}
      - DEVELOPMENT=${DEVELOPMENT}
      - JWT_SECRET=${JWT_SECRET}
      - AUTHAPP_DB_PASS=${AUTHAPP_DB_PASS}
      - AUTHAPP_DB_USER=${AUTHAPP_DB_USER}

    volumes:
      - "./db/src:/docker-entrypoint-initdb.d"

  authapp:
    build: authapp
    # Set the location where docker will put our files
    working_dir: /app
    # Map port 8081 on our host to port 4000 inside the container.
    # Our node app should then run on port 4000 inside the container.
    ports:
      - "8081:${AUTHAPP_PORT}"
    # Link this app to the `db` app so that we can talk to postgres
    # when we need to do so. We might also want to talk to the rest
    # API directly, and we'll need to add that if so.
    links:
      - redis:redis
      - mockcas:mockcas
    environment:
      # Pass in connection information for the database.
      - DB_URI=postgres://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}
      # The express app will likely manage some of our JWT signing
      # because we want to use Yale CAS auth infront of our app so
      # that we can avoid storing passwords.
      # - JWT_SECRET=${JWT_SECRET}  
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
      - SESSION_SECRET=${AUTHAPP_SESSION_SECRET}
      - DEVELOPMENT=${DEVELOPMENT}
      - CAS_HOST=${AUTHAPP_CAS_HOST}
      - CAS_SERVICE_VALIDATE_HOST=${AUTHAPP_CAS_SERVICE_VALIDATE_HOST}
      - CAS_PROTOCOL=${AUTHAPP_CAS_PROTOCOL}
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT}
      - DB_SCHEMA=${DB_SCHEMA}
      - DB_NAME=${DB_NAME}
      - DB_USER=${AUTHAPP_DB_USER}
      - DB_PASS=${AUTHAPP_DB_PASS}
      - JWT_SECRET=${JWT_SECRET}



    volumes:
      # These are the files we wish to "move" into the docker container.
      # Note that, they are not moved, just mounted---when they are
      # edited on the host they will be changed in the container.
      # - "./authapp/package.json:/app/package.json"
      # - "./authapp/package-lock.json:/app/package-lock.json"
      - "./authapp/src:/app/src"
      - "./authapp/run.sh:/app/run.sh"
    # The script that is run to start our process.
    entrypoint: "/app/run.sh"

  elmclient:
    build: elmclient
    # Set the location where docker will put our files
    working_dir: /opt/app
    # Map port 8081 on our host to port 4000 inside the container.
    # Our node app should then run on port 4000 inside the container.
    ports:
      - "8082:${ELMCLIENT_PORT}"
    environment:
      - DEVELOPMENT=${DEVELOPMENT}
      - ELMCLIENT_PORT=${ELMCLIENT_PORT}
    volumes:
      # Note that the package.json-like files were moved into the
      # container as specified by the elmclient/Dockerfile.
      - elmclient-build:/opt/app/dist
      - "./elmclient/src:/opt/app/src"
      - "./elmclient/run.sh:/opt/app/run.sh"
      - "./elmclient/webpack.config.js:/opt/app/webpack.config.js"
    entrypoint: "/opt/app/run.sh"

  mockcas:
    build: mockcas
    # Set the location where docker will put our files
    working_dir: /opt/app
    # Map port 8081 on our host to port 4000 inside the container.
    # Our node app should then run on port 4000 inside the container.
    ports:
      - "${MOCKCAS_HOST_PORT}:${MOCKCAS_PORT}"
    environment:
      - DEVELOPMENT=${DEVELOPMENT}
      - PORT=${MOCKCAS_PORT}
    volumes:
      # Note that the package.json-like files were moved into the
      # container as specified by the elmclient/Dockerfile.
      - "./mockcas/src:/opt/app/src"
      - "./mockcas/run.sh:/opt/app/run.sh"
    entrypoint: "/opt/app/run.sh"

  # PostgREST instance, is responsible for communicating with the database
  # and providing a REST api, (almost) every request that is sent to the database goes through it
  postgrest:
    image: postgrest/postgrest
    ports:
      - "3000:${POSTGREST_PORT}"
    links:
      - db:db
    environment:
      - PGRST_DB_URI=postgres://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}
      - PGRST_DB_SCHEMA=${DB_SCHEMA} 
      - PGRST_DB_ANON_ROLE=${DB_ANON_ROLE}
      - PGRST_DB_POOL=${DB_POOL} 
      - PGRST_JWT_SECRET=${JWT_SECRET}  
      - PGRST_MAX_ROWS=${MAX_ROWS} 
      - PGRST_PRE_REQUEST=${PRE_REQUEST}
      - PGRST_SERVER_PROXY_URI=${SERVER_PROXY_URI}

  # OpenResty (Nginx + Lua) instance that sits in front of PostgREST.
  # All the requests comming into the system are first hitting this component.
  # After some processing/checks and transformation, the request is forwarded
  # to PostgREST down the stack.
  openresty:
    image: openresty/openresty:jessie
    ports:
      - "8080:80"
    links:
      - db:db
      - postgrest:postgrest
      - authapp:authapp
    entrypoint: /entrypoint.sh
    environment:
      - JWT_SECRET=${JWT_SECRET}
      - DEVELOPMENT=${DEVELOPMENT}
      - POSTGREST_HOST=${POSTGREST_HOST}
      - POSTGREST_PORT=${POSTGREST_PORT}
      - AUTHAPP_HOST=${AUTHAPP_HOST}
      - AUTHAPP_PORT=${AUTHAPP_PORT}
      - ELMCLIENT_HOST=${ELMCLIENT_HOST}
      - ELMCLIENT_PORT=${ELMCLIENT_PORT}
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT}
      - DB_NAME=${DB_NAME}
      - DB_SCHEMA=${DB_SCHEMA}
      - DB_USER=${DB_USER}
      - DB_PASS=${DB_PASS}
    volumes:
      - elmclient-build:/var/elmclient/
      - "./openresty/entrypoint.sh:/entrypoint.sh"
      - "./openresty/nginx/conf/nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf"
      - "./openresty/nginx/conf/includes:/usr/local/openresty/nginx/conf/includes"
      - "./openresty/nginx/html:/usr/local/openresty/nginx/html"
      - "./openresty/lualib/user_code:/usr/local/openresty/lualib/user_code"

  # pg-amqp-bridge instance is responsible for forwarding NOTIFY events in PostgreSQL
  # to RabbitMQ based on the BRIDGE_CHANNELS configuration
  pg_amqp_bridge:
    image: subzerocloud/pg-amqp-bridge
    links:
      - db
      - rabbitmq
    environment:
      - POSTGRESQL_URI=postgres://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}
      - AMQP_URI=amqp://${RABBITMQ_DEFAULT_USER}:${RABBITMQ_DEFAULT_PASS}@rabbitmq//
      - BRIDGE_CHANNELS=events:amq.topic

  # RabbitMQ instance can be used to consolidate events that originated in your database/application.
  # You can connect here with different consumers and take actions based on those events (like sending signup emails)
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5671:5671"
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_DEFAULT_USER}
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_DEFAULT_PASS}
  redis:
    image: redis:4
    ports:
      - "6379:6379"